\hypertarget{dg__solver__shallow__water_8h_source}{}\doxysection{dg\+\_\+solver\+\_\+shallow\+\_\+water.\+h}
\label{dg__solver__shallow__water_8h_source}\index{Solvers/dg\_solver\_shallow\_water.h@{Solvers/dg\_solver\_shallow\_water.h}}
\mbox{\hyperlink{dg__solver__shallow__water_8h}{Go to the documentation of this file.}}
\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{preprocessor}{\#ifndef CORENC\_SOLVERS\_DG\_SOLVER\_SHALLOW\_WATER\_H\_}}
\DoxyCodeLine{2 \textcolor{preprocessor}{\#define CORENC\_SOLVERS\_DG\_SOLVER\_SHALLOW\_WATER\_H\_}}
\DoxyCodeLine{3 }
\DoxyCodeLine{4 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{5 \textcolor{preprocessor}{\#include <functional>}}
\DoxyCodeLine{6 \textcolor{preprocessor}{\#include <istream>}}
\DoxyCodeLine{7 \textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{8 \textcolor{preprocessor}{\#include <fstream>}}
\DoxyCodeLine{9 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{10 \textcolor{preprocessor}{\#include "{}../CoreNCFEM/Point.h"{}}}
\DoxyCodeLine{11 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacecorenc}{corenc}}}
\DoxyCodeLine{12 \{}
\DoxyCodeLine{13     \textcolor{keyword}{namespace }solvers}
\DoxyCodeLine{14     \{}
\DoxyCodeLine{15         \textcolor{keyword}{struct }\mbox{\hyperlink{structcorenc_1_1solvers_1_1vector__solution}{vector\_solution}}}
\DoxyCodeLine{16         \{}
\DoxyCodeLine{17             std::vector<double> \mbox{\hyperlink{structcorenc_1_1solvers_1_1vector__solution_a4ec287397ffb7e274ad675a6189460f6}{S}}[3];}
\DoxyCodeLine{18             \mbox{\hyperlink{structcorenc_1_1solvers_1_1vector__solution_a5e32da65bd29d510338db18a9a98b7eb}{vector\_solution}}() \{\}}
\DoxyCodeLine{19             \mbox{\hyperlink{structcorenc_1_1solvers_1_1vector__solution_ada538e5360c11e8fb671843b6b8812d4}{vector\_solution}}(\textcolor{keyword}{const} \textcolor{keywordtype}{int} \_size)}
\DoxyCodeLine{20             \{}
\DoxyCodeLine{21                 \mbox{\hyperlink{structcorenc_1_1solvers_1_1vector__solution_a4ec287397ffb7e274ad675a6189460f6}{S}}[0].resize(\_size);}
\DoxyCodeLine{22                 \mbox{\hyperlink{structcorenc_1_1solvers_1_1vector__solution_a4ec287397ffb7e274ad675a6189460f6}{S}}[1].resize(\_size);}
\DoxyCodeLine{23                 \mbox{\hyperlink{structcorenc_1_1solvers_1_1vector__solution_a4ec287397ffb7e274ad675a6189460f6}{S}}[2].resize(\_size);}
\DoxyCodeLine{24             \}}
\DoxyCodeLine{25         \};}
\DoxyCodeLine{26         \textcolor{keyword}{class }\mbox{\hyperlink{classcorenc_1_1solvers_1_1dg__solver__shallow__water}{dg\_solver\_shallow\_water}}}
\DoxyCodeLine{27         \{}
\DoxyCodeLine{28         \textcolor{keyword}{public}:}
\DoxyCodeLine{29             \mbox{\hyperlink{classcorenc_1_1solvers_1_1dg__solver__shallow__water_a9ff181e5a4e9d6bb18f485c813970a81}{dg\_solver\_shallow\_water}}();}
\DoxyCodeLine{30             \mbox{\hyperlink{classcorenc_1_1solvers_1_1dg__solver__shallow__water_a69dee84f42ff8d27d755418b60b22273}{\string~dg\_solver\_shallow\_water}}();}
\DoxyCodeLine{31             \textcolor{keyword}{const} \textcolor{keywordtype}{int}               \mbox{\hyperlink{classcorenc_1_1solvers_1_1dg__solver__shallow__water_a626056c2ba3c479109c0686e0b1ed596}{solve}}() \textcolor{keyword}{const};}
\DoxyCodeLine{32             \textcolor{keyword}{const} \textcolor{keywordtype}{int}               \mbox{\hyperlink{classcorenc_1_1solvers_1_1dg__solver__shallow__water_af3741feab6f32ce8efb5d3f1f1e1ed1d}{solve}}(}
\DoxyCodeLine{33                 \textcolor{keyword}{const} \textcolor{keywordtype}{double} t0,}
\DoxyCodeLine{34                 \textcolor{keyword}{const} \textcolor{keywordtype}{double} t1,}
\DoxyCodeLine{35                 \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} nx,}
\DoxyCodeLine{36                 \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} ny,}
\DoxyCodeLine{37                 \textcolor{keyword}{const} \textcolor{keywordtype}{double} x0,}
\DoxyCodeLine{38                 \textcolor{keyword}{const} \textcolor{keywordtype}{double} x1,}
\DoxyCodeLine{39                 \textcolor{keyword}{const} \textcolor{keywordtype}{double} y0,}
\DoxyCodeLine{40                 \textcolor{keyword}{const} \textcolor{keywordtype}{double} y1,}
\DoxyCodeLine{41                 \textcolor{keyword}{const} \textcolor{keywordtype}{double} g,}
\DoxyCodeLine{42                 \textcolor{keyword}{const} \textcolor{keywordtype}{double} H,}
\DoxyCodeLine{43                 \textcolor{keyword}{const} std::function<\textcolor{keyword}{const} std::vector<double>(\textcolor{keyword}{const} std::vector<double>\&)>\&, }
\DoxyCodeLine{44                 \textcolor{keyword}{const} std::function<\textcolor{keyword}{const} std::vector<double>(\textcolor{keyword}{const} std::vector<double>\&)>\&,}
\DoxyCodeLine{45                 \textcolor{keyword}{const} std::function<\textcolor{keyword}{const} std::vector<double>(\textcolor{keyword}{const} std::vector<double>\&)>\&) \textcolor{keyword}{const};}
\DoxyCodeLine{46         \};}
\DoxyCodeLine{47         }
\DoxyCodeLine{48         \textcolor{keyword}{template}<\textcolor{keyword}{class} Mesh>}
\DoxyCodeLine{49         \textcolor{keyword}{class }\mbox{\hyperlink{classcorenc_1_1solvers_1_1dg__shallow__water}{dg\_shallow\_water}}}
\DoxyCodeLine{50         \{}
\DoxyCodeLine{51         \textcolor{keyword}{public}:}
\DoxyCodeLine{52             \mbox{\hyperlink{classcorenc_1_1solvers_1_1dg__shallow__water_a5f1e276fe29e7eedd37ee88f4d9ac70c}{dg\_shallow\_water}}();}
\DoxyCodeLine{53             \mbox{\hyperlink{classcorenc_1_1solvers_1_1dg__shallow__water_a6b5b277c58d1017a51fcc987c1a2eb64}{\string~dg\_shallow\_water}}();}
\DoxyCodeLine{54             \textcolor{keyword}{const} \textcolor{keywordtype}{int}               \mbox{\hyperlink{classcorenc_1_1solvers_1_1dg__shallow__water_a68503609a376fd70e0e19a9495748e91}{solve}}(}
\DoxyCodeLine{55                 \textcolor{keyword}{const} \textcolor{keywordtype}{double} t0,}
\DoxyCodeLine{56                 \textcolor{keyword}{const} \textcolor{keywordtype}{double} t1,}
\DoxyCodeLine{57                 \textcolor{keyword}{const} Mesh\& mesh,}
\DoxyCodeLine{58                 \mbox{\hyperlink{structcorenc_1_1solvers_1_1vector__solution}{vector\_solution}}\& sol,}
\DoxyCodeLine{59                 \textcolor{keyword}{const} std::function<\textcolor{keyword}{const} std::vector<double>(\textcolor{keyword}{const} std::vector<double>\&)>\&,}
\DoxyCodeLine{60                 \textcolor{keyword}{const} std::function<\textcolor{keyword}{const} std::vector<double>(\textcolor{keyword}{const} std::vector<double>\&)>\&,}
\DoxyCodeLine{61                 \textcolor{keyword}{const} std::function<\textcolor{keyword}{const} std::vector<double>(\textcolor{keyword}{const} std::vector<double>\&)>\&) \textcolor{keyword}{const};}
\DoxyCodeLine{62             \textcolor{keyword}{const} \textcolor{keywordtype}{int}               \mbox{\hyperlink{classcorenc_1_1solvers_1_1dg__shallow__water_a68503609a376fd70e0e19a9495748e91}{solve}}(}
\DoxyCodeLine{63                 \textcolor{keyword}{const} \textcolor{keywordtype}{double} t0,}
\DoxyCodeLine{64                 \textcolor{keyword}{const} \textcolor{keywordtype}{double} t1,}
\DoxyCodeLine{65                 \textcolor{keyword}{const} Mesh\& mesh,}
\DoxyCodeLine{66                 \mbox{\hyperlink{structcorenc_1_1solvers_1_1vector__solution}{vector\_solution}}\& sol,}
\DoxyCodeLine{67                 std::vector<double>\& bath,}
\DoxyCodeLine{68                 std::vector<double>\& ze,}
\DoxyCodeLine{69                 std::vector<double>\& dzx,}
\DoxyCodeLine{70                 std::vector<double>\& dzy,}
\DoxyCodeLine{71                 std::vector<double>\& dbx,}
\DoxyCodeLine{72                 std::vector<double>\& dby,}
\DoxyCodeLine{73                 \textcolor{keyword}{const} std::function<\textcolor{keyword}{const} std::vector<double>(\textcolor{keyword}{const} std::vector<double>\&, \textcolor{keyword}{const} \textcolor{keywordtype}{int})>\&,}
\DoxyCodeLine{74                 \textcolor{keyword}{const} std::function<\textcolor{keyword}{const} std::vector<double>(\textcolor{keyword}{const} std::vector<double>\&, \textcolor{keyword}{const} \textcolor{keywordtype}{int})>\&,}
\DoxyCodeLine{75                 \textcolor{keyword}{const} std::function<\textcolor{keyword}{const} std::vector<double>(\textcolor{keyword}{const} std::vector<double>\&, \textcolor{keyword}{const} \textcolor{keywordtype}{int})>\&,}
\DoxyCodeLine{76                 \textcolor{keyword}{const} \textcolor{keywordtype}{bool} WRITE\_FILE) \textcolor{keyword}{const};}
\DoxyCodeLine{77         \};}
\DoxyCodeLine{78         }
\DoxyCodeLine{79         \textcolor{keyword}{template}<\textcolor{keyword}{class} Mesh>}
\DoxyCodeLine{80         \mbox{\hyperlink{classcorenc_1_1solvers_1_1dg__shallow__water_a5f1e276fe29e7eedd37ee88f4d9ac70c}{dg\_shallow\_water<Mesh>::dg\_shallow\_water}}()}
\DoxyCodeLine{81         \{}
\DoxyCodeLine{82 }
\DoxyCodeLine{83         \}}
\DoxyCodeLine{84         \textcolor{keyword}{template}<\textcolor{keyword}{class} Mesh>}
\DoxyCodeLine{85         \mbox{\hyperlink{classcorenc_1_1solvers_1_1dg__shallow__water_a6b5b277c58d1017a51fcc987c1a2eb64}{dg\_shallow\_water<Mesh>::\string~dg\_shallow\_water}}()}
\DoxyCodeLine{86         \{}
\DoxyCodeLine{87 }
\DoxyCodeLine{88         \}}
\DoxyCodeLine{89         }
\DoxyCodeLine{90         \textcolor{keyword}{template}<\textcolor{keyword}{class} Mesh>}
\DoxyCodeLine{91         \textcolor{keyword}{const} \textcolor{keywordtype}{int} \mbox{\hyperlink{classcorenc_1_1solvers_1_1dg__shallow__water_a68503609a376fd70e0e19a9495748e91}{dg\_shallow\_water<Mesh>::solve}}(}
\DoxyCodeLine{92             \textcolor{keyword}{const} \textcolor{keywordtype}{double} t0,}
\DoxyCodeLine{93             \textcolor{keyword}{const} \textcolor{keywordtype}{double} t1,}
\DoxyCodeLine{94             \textcolor{keyword}{const} Mesh\& mesh,}
\DoxyCodeLine{95             \mbox{\hyperlink{structcorenc_1_1solvers_1_1vector__solution}{vector\_solution}}\& sol,}
\DoxyCodeLine{96             \textcolor{keyword}{const} std::function < \textcolor{keyword}{const} std::vector<double>(\textcolor{keyword}{const} std::vector<double>\&)>\&R,}
\DoxyCodeLine{97             \textcolor{keyword}{const} std::function < \textcolor{keyword}{const} std::vector<double>(\textcolor{keyword}{const} std::vector<double>\&)>\&G,}
\DoxyCodeLine{98             \textcolor{keyword}{const} std::function < \textcolor{keyword}{const} std::vector<double>(\textcolor{keyword}{const} std::vector<double>\&)>\&F)\textcolor{keyword}{ const}}
\DoxyCodeLine{99 \textcolor{keyword}{        }\{}
\DoxyCodeLine{100             std::vector<double> Ut[3];}
\DoxyCodeLine{101             \textcolor{keyword}{const} \textcolor{keywordtype}{int} max\_iter = 30000;}
\DoxyCodeLine{102             \textcolor{keyword}{const} \textcolor{keywordtype}{double} dx = mesh.GetNode(mesh.GetNumberOfNodes() -\/ 1).x -\/ mesh.GetNode(0).x;}
\DoxyCodeLine{103             \textcolor{keyword}{const} \textcolor{keywordtype}{double} dy = mesh.GetNode(mesh.GetNumberOfNodes() -\/ 1).y -\/ mesh.GetNode(0).y;}
\DoxyCodeLine{104             \textcolor{comment}{//const double dx = (x1 -\/ x0) / nx;}}
\DoxyCodeLine{105             \textcolor{comment}{//const double dy = (y1 -\/ y0) / ny;}}
\DoxyCodeLine{106             \textcolor{keyword}{const} \textcolor{keywordtype}{int} size = mesh.GetNumberOfElements();}
\DoxyCodeLine{107             \textcolor{keyword}{const} \textcolor{keywordtype}{int} bsize = mesh.GetNumberOfBoundaries();}
\DoxyCodeLine{108             }
\DoxyCodeLine{109             std::vector<vector\_solution> U(2);}
\DoxyCodeLine{110             std::vector<vector\_solution> W(2);}
\DoxyCodeLine{111             U[0].S[0].resize(size);}
\DoxyCodeLine{112             U[0].S[1].resize(size);}
\DoxyCodeLine{113             U[0].S[2].resize(size);}
\DoxyCodeLine{114             U[1].S[0].resize(size);}
\DoxyCodeLine{115             U[1].S[1].resize(size);}
\DoxyCodeLine{116             U[1].S[2].resize(size);}
\DoxyCodeLine{117 }
\DoxyCodeLine{118             W[0].S[0].resize(size);}
\DoxyCodeLine{119             W[0].S[1].resize(size);}
\DoxyCodeLine{120             W[0].S[2].resize(size);}
\DoxyCodeLine{121             W[1].S[0].resize(size);}
\DoxyCodeLine{122             W[1].S[1].resize(size);}
\DoxyCodeLine{123             W[1].S[2].resize(size);}
\DoxyCodeLine{124             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < size; ++i)}
\DoxyCodeLine{125             \{}
\DoxyCodeLine{126                 W[0].S[0][i] = sol.\mbox{\hyperlink{structcorenc_1_1solvers_1_1vector__solution_a4ec287397ffb7e274ad675a6189460f6}{S}}[0][i];}
\DoxyCodeLine{127                 W[0].S[1][i] = sol.\mbox{\hyperlink{structcorenc_1_1solvers_1_1vector__solution_a4ec287397ffb7e274ad675a6189460f6}{S}}[1][i];}
\DoxyCodeLine{128                 W[0].S[2][i] = sol.\mbox{\hyperlink{structcorenc_1_1solvers_1_1vector__solution_a4ec287397ffb7e274ad675a6189460f6}{S}}[2][i];}
\DoxyCodeLine{129 }
\DoxyCodeLine{130                 U[0].S[0][i] = sol.\mbox{\hyperlink{structcorenc_1_1solvers_1_1vector__solution_a4ec287397ffb7e274ad675a6189460f6}{S}}[0][i];}
\DoxyCodeLine{131                 U[0].S[1][i] = sol.\mbox{\hyperlink{structcorenc_1_1solvers_1_1vector__solution_a4ec287397ffb7e274ad675a6189460f6}{S}}[1][i] / sol.\mbox{\hyperlink{structcorenc_1_1solvers_1_1vector__solution_a4ec287397ffb7e274ad675a6189460f6}{S}}[0][i];}
\DoxyCodeLine{132                 U[0].S[2][i] = sol.\mbox{\hyperlink{structcorenc_1_1solvers_1_1vector__solution_a4ec287397ffb7e274ad675a6189460f6}{S}}[2][i] / sol.\mbox{\hyperlink{structcorenc_1_1solvers_1_1vector__solution_a4ec287397ffb7e274ad675a6189460f6}{S}}[0][i];}
\DoxyCodeLine{133             \}}
\DoxyCodeLine{134 }
\DoxyCodeLine{135             \textcolor{keywordtype}{double} t\_step = 0.1;}
\DoxyCodeLine{136             \textcolor{keyword}{const} \textcolor{keywordtype}{double} cfl = 0.5;}
\DoxyCodeLine{137             \textcolor{comment}{// W = [h hu hv]}}
\DoxyCodeLine{138             \textcolor{keywordtype}{double} lambda\_x = 0;}
\DoxyCodeLine{139             \textcolor{keywordtype}{double} lambda\_y = 0;}
\DoxyCodeLine{140             \textcolor{keywordtype}{double} lambdax = 0;}
\DoxyCodeLine{141             \textcolor{keywordtype}{double} lambday = 0;}
\DoxyCodeLine{142             \textcolor{keywordtype}{double} lambda = 0;}
\DoxyCodeLine{143             \textcolor{keywordtype}{double} t\_curr = 0;}
\DoxyCodeLine{144             \textcolor{keywordtype}{double} g = 1;}
\DoxyCodeLine{145             \textcolor{keywordtype}{size\_t} iter\_max = 10000;}
\DoxyCodeLine{146             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} t = 0; t < iter\_max \&\& t\_curr < t1; ++t, t\_curr += t\_step)}
\DoxyCodeLine{147             \{}
\DoxyCodeLine{148                 lambda\_x = 0;}
\DoxyCodeLine{149                 lambda\_y = 0;}
\DoxyCodeLine{150                 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < size; ++i)}
\DoxyCodeLine{151                 \{}
\DoxyCodeLine{152                     \textcolor{keyword}{const} \textcolor{keyword}{auto}\& elem = mesh.GetElement(i);}
\DoxyCodeLine{153                     \textcolor{keyword}{const} \textcolor{keyword}{auto}\& res = F(std::vector<double>\{W[t].S[0][i], W[t].S[1][i], W[t].S[2][i]\});}
\DoxyCodeLine{154                     W[t + 1].S[0][i] = W[t].S[0][i] + res[0];}
\DoxyCodeLine{155                     W[t + 1].S[1][i] = W[t].S[1][i] + res[1];}
\DoxyCodeLine{156                     W[t + 1].S[2][i] = W[t].S[2][i] + res[2];}
\DoxyCodeLine{157 }
\DoxyCodeLine{158                     lambda\_x = std::max(fabs(U[t].S[1][i]), lambda\_x);}
\DoxyCodeLine{159                     lambda\_y = std::max(fabs(U[t].S[2][i]), lambda\_y);}
\DoxyCodeLine{160                 \}}
\DoxyCodeLine{161                 t\_step = cfl / 2 * std::min(dx / lambda\_x, dy / lambda\_y);}
\DoxyCodeLine{162                 \textcolor{keywordflow}{if} (t\_curr + t\_step > t1)}
\DoxyCodeLine{163                     t\_step = t1 -\/ t\_curr;}
\DoxyCodeLine{164                 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < bsize; ++i)}
\DoxyCodeLine{165                 \{}
\DoxyCodeLine{166                     \textcolor{keyword}{const} \textcolor{keyword}{auto}\& bound = mesh.GetBoundary(i);}
\DoxyCodeLine{167                     \textcolor{keyword}{const} \textcolor{keywordtype}{int} nk = bound-\/>GetNeighbour(0);}
\DoxyCodeLine{168                     \textcolor{keyword}{const} \textcolor{keywordtype}{int} ne = bound-\/>GetNeighbour(1);}
\DoxyCodeLine{169                     \textcolor{keyword}{const} \textcolor{keyword}{auto}\& normal = bound-\/>GetNormal();}
\DoxyCodeLine{170                     \textcolor{keywordflow}{if} (ne > -\/1)}
\DoxyCodeLine{171                     \{}
\DoxyCodeLine{172                         \textcolor{keyword}{const} \textcolor{keyword}{auto}\& normal = bound-\/>GetNormal();}
\DoxyCodeLine{173                         std::vector<double> wk(3);}
\DoxyCodeLine{174                         wk[0] = U[t].S[0][nk];}
\DoxyCodeLine{175                         wk[1] = U[t].S[1][nk] * U[t].S[0][nk];}
\DoxyCodeLine{176                         wk[2] = U[t].S[2][nk] * U[t].S[0][nk];}
\DoxyCodeLine{177 }
\DoxyCodeLine{178                         std::vector<double> we(3);}
\DoxyCodeLine{179                         we[0] = U[t].S[0][ne];}
\DoxyCodeLine{180                         we[1] = U[t].S[1][ne] * U[t].S[0][ne];}
\DoxyCodeLine{181                         we[2] = U[t].S[2][ne] * U[t].S[0][ne];}
\DoxyCodeLine{182 }
\DoxyCodeLine{183                         \textcolor{comment}{//lambda\_x = std::max(fabs(U[t].S[1][nk]) + sqrt(g * U[t].S[0][nk]), fabs(U[t].S[1][ne]) + sqrt(g * U[t].S[0][ne]));}}
\DoxyCodeLine{184                         \textcolor{comment}{//lambda\_y = std::max(fabs(U[t].S[2][nk]) + sqrt(g * U[t].S[0][nk]), fabs(U[t].S[2][ne]) + sqrt(g * U[t].S[0][ne]));}}
\DoxyCodeLine{185 }
\DoxyCodeLine{186                         lambda\_x = std::max(fabs(U[t].S[1][nk]), fabs(U[t].S[1][ne]));}
\DoxyCodeLine{187                         lambda\_y = std::max(fabs(U[t].S[2][nk]), fabs(U[t].S[2][ne]));}
\DoxyCodeLine{188 }
\DoxyCodeLine{189 }
\DoxyCodeLine{190                         lambdax = std::max(lambdax, lambda\_x);}
\DoxyCodeLine{191                         lambday = std::max(lambday, lambda\_y);}
\DoxyCodeLine{192                         \textcolor{keywordtype}{double} ll = std::max(lambda\_x, lambda\_y);}
\DoxyCodeLine{193                         \textcolor{comment}{//cout << "{}max:\(\backslash\)t"{} << ll << endl;}}
\DoxyCodeLine{194                         std::vector<double> uk(3);}
\DoxyCodeLine{195                         uk[0] = U[t].S[0][nk];}
\DoxyCodeLine{196                         uk[1] = U[t].S[1][nk];}
\DoxyCodeLine{197                         uk[2] = U[t].S[2][nk];}
\DoxyCodeLine{198 }
\DoxyCodeLine{199                         std::vector<double> ue(3);}
\DoxyCodeLine{200                         ue[0] = U[t].S[0][ne];}
\DoxyCodeLine{201                         ue[1] = U[t].S[1][ne];}
\DoxyCodeLine{202                         ue[2] = U[t].S[2][ne];}
\DoxyCodeLine{203 }
\DoxyCodeLine{204                         \textcolor{keyword}{const} \textcolor{keyword}{auto} rk = R(uk);}
\DoxyCodeLine{205                         \textcolor{keyword}{const} \textcolor{keyword}{auto} re = R(ue);}
\DoxyCodeLine{206                         \textcolor{keyword}{const} \textcolor{keyword}{auto} gk = G(uk);}
\DoxyCodeLine{207                         \textcolor{keyword}{const} \textcolor{keyword}{auto} ge = G(ue);}
\DoxyCodeLine{208 }
\DoxyCodeLine{209                         std::vector<double> uu(3);}
\DoxyCodeLine{210                         uu[0] = t\_step / mesh.GetElement(nk)-\/>GetMeasure() * bound-\/>GetMeasure() * (normal.x * (rk[0] + re[0]) / 2 + normal.y * (gk[0] + ge[0]) / 2 -\/ (lambda\_x * normal.x / 2 * (ue[0] -\/ uk[0]) + lambda\_y * normal.y / 2 * (ue[0] -\/ uk[0])));}
\DoxyCodeLine{211                         uu[1] = t\_step / mesh.GetElement(nk)-\/>GetMeasure() * bound-\/>GetMeasure() * (normal.x * (rk[1] + re[1]) / 2 + normal.y * (gk[1] + ge[1]) / 2 -\/ (lambda\_x * normal.x / 2 * (ue[1] -\/ uk[1]) + lambda\_y * normal.y / 2 * (ue[1] -\/ uk[1])));}
\DoxyCodeLine{212                         uu[2] = t\_step / mesh.GetElement(nk)-\/>GetMeasure() * bound-\/>GetMeasure() * (normal.x * (rk[2] + re[2]) / 2 + normal.y * (gk[2] + ge[2]) / 2 -\/ (lambda\_x * normal.x / 2 * (ue[2] -\/ uk[2]) + lambda\_y * normal.y / 2 * (ue[2] -\/ uk[2])));}
\DoxyCodeLine{213                         W[t + 1].S[0][nk] -\/= uu[0];}
\DoxyCodeLine{214                         W[t + 1].S[1][nk] -\/= uu[1];}
\DoxyCodeLine{215                         W[t + 1].S[2][nk] -\/= uu[2];}
\DoxyCodeLine{216 }
\DoxyCodeLine{217                         uu[0] = t\_step / mesh.GetElement(nk)-\/>GetMeasure() * bound-\/>GetMeasure() * (-\/normal.x * (rk[0] + re[0]) / 2 -\/ normal.y * (gk[0] + ge[0]) / 2 + (lambda\_x * normal.x / 2 * (ue[0] -\/ uk[0]) + lambda\_y * normal.y / 2 * (ue[0] -\/ uk[0])));}
\DoxyCodeLine{218                         uu[1] = t\_step / mesh.GetElement(nk)-\/>GetMeasure() * bound-\/>GetMeasure() * (-\/normal.x * (rk[1] + re[1]) / 2 -\/ normal.y * (gk[1] + ge[1]) / 2 + (lambda\_x * normal.x / 2 * (ue[1] -\/ uk[1]) + lambda\_y * normal.y / 2 * (ue[1] -\/ uk[1])));}
\DoxyCodeLine{219                         uu[2] = t\_step / mesh.GetElement(nk)-\/>GetMeasure() * bound-\/>GetMeasure() * (-\/normal.x * (rk[2] + re[2]) / 2 -\/ normal.y * (gk[2] + ge[2]) / 2 + (lambda\_x * normal.x / 2 * (ue[2] -\/ uk[2]) + lambda\_y * normal.y / 2 * (ue[2] -\/ uk[2])));}
\DoxyCodeLine{220                         W[t + 1].S[0][ne] -\/= uu[0];}
\DoxyCodeLine{221                         W[t + 1].S[1][ne] -\/= uu[1];}
\DoxyCodeLine{222                         W[t + 1].S[2][ne] -\/= uu[2];}
\DoxyCodeLine{223                     \}}
\DoxyCodeLine{224                 \}}
\DoxyCodeLine{225                 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < bsize; ++i)}
\DoxyCodeLine{226                 \{}
\DoxyCodeLine{227                     \textcolor{keyword}{const} \textcolor{keyword}{auto}\& bound = mesh.GetBoundary(i);}
\DoxyCodeLine{228                     \textcolor{keyword}{const} \textcolor{keywordtype}{int} nk = bound-\/>GetNeighbour(0);}
\DoxyCodeLine{229                     \textcolor{keyword}{const} \textcolor{keywordtype}{int} ne = bound-\/>GetNeighbour(1);}
\DoxyCodeLine{230                     \textcolor{keywordflow}{if} (ne == -\/1)}
\DoxyCodeLine{231                     \{}
\DoxyCodeLine{232                         \textcolor{keyword}{auto} normal = bound-\/>GetNormal();}
\DoxyCodeLine{233 }
\DoxyCodeLine{234                         std::vector<double> u(3);}
\DoxyCodeLine{235                         u[0] = U[t].S[0][nk];}
\DoxyCodeLine{236                         u[1] = -\/U[t].S[1][nk];}
\DoxyCodeLine{237                         u[2] = -\/U[t].S[2][nk];}
\DoxyCodeLine{238 }
\DoxyCodeLine{239                         lambdax = std::max(lambdax, lambda\_x);}
\DoxyCodeLine{240                         lambday = std::max(lambday, lambda\_y);}
\DoxyCodeLine{241 }
\DoxyCodeLine{242                         std::vector<double> uk(3);}
\DoxyCodeLine{243                         uk[0] = U[t].S[0][nk];}
\DoxyCodeLine{244                         uk[1] = U[t].S[1][nk];}
\DoxyCodeLine{245                         uk[2] = U[t].S[2][nk];}
\DoxyCodeLine{246 }
\DoxyCodeLine{247                         std::vector<double> ue(3);}
\DoxyCodeLine{248                         ue[0] = u[0];}
\DoxyCodeLine{249                         ue[1] = u[1];}
\DoxyCodeLine{250                         ue[2] = u[2];}
\DoxyCodeLine{251 }
\DoxyCodeLine{252                         \textcolor{keyword}{const} \textcolor{keyword}{auto} rk = R(uk);}
\DoxyCodeLine{253                         \textcolor{keyword}{const} \textcolor{keyword}{auto} re = R(ue);}
\DoxyCodeLine{254                         \textcolor{keyword}{const} \textcolor{keyword}{auto} gk = G(uk);}
\DoxyCodeLine{255                         \textcolor{keyword}{const} \textcolor{keyword}{auto} ge = G(ue);}
\DoxyCodeLine{256                         lambda\_x = std::max(fabs(uk[1]), fabs(ue[1]));}
\DoxyCodeLine{257                         lambda\_y = std::max(fabs(uk[2]), fabs(ue[2]));}
\DoxyCodeLine{258                         std::vector<double> uu(3);}
\DoxyCodeLine{259                         \textcolor{keywordflow}{if} (normal.x > 0 || normal.y > 0)}
\DoxyCodeLine{260                         \{}
\DoxyCodeLine{261                             uu[0] = t\_step / mesh.GetElement(nk)-\/>GetMeasure() * bound-\/>GetMeasure() * (normal.x * (rk[0] + re[0]) / 2 + normal.y * (gk[0] + ge[0]) / 2 -\/ (lambda\_x * normal.x / 2 * (ue[0] -\/ uk[0]) + lambda\_y * normal.y / 2 * (ue[0] -\/ uk[0])));}
\DoxyCodeLine{262                             uu[1] = t\_step / mesh.GetElement(nk)-\/>GetMeasure() * bound-\/>GetMeasure() * (normal.x * (rk[1] + re[1]) / 2 + normal.y * (gk[1] + ge[1]) / 2 -\/ (lambda\_x * normal.x / 2 * (ue[1] -\/ uk[1]) + lambda\_y * normal.y / 2 * (ue[1] -\/ uk[1])));}
\DoxyCodeLine{263                             uu[2] = t\_step / mesh.GetElement(nk)-\/>GetMeasure() * bound-\/>GetMeasure() * (normal.x * (rk[2] + re[2]) / 2 + normal.y * (gk[2] + ge[2]) / 2 -\/ (lambda\_x * normal.x / 2 * (ue[2] -\/ uk[2]) + lambda\_y * normal.y / 2 * (ue[2] -\/ uk[2])));}
\DoxyCodeLine{264                         \}}
\DoxyCodeLine{265                         \textcolor{keywordflow}{else}}
\DoxyCodeLine{266                         \{}
\DoxyCodeLine{267                             uu[0] = t\_step / mesh.GetElement(nk)-\/>GetMeasure() * bound-\/>GetMeasure() * (normal.x * (rk[0] + re[0]) / 2 + normal.y * (gk[0] + ge[0]) / 2 + (lambda\_x * normal.x / 2 * (ue[0] -\/ uk[0]) + lambda\_y * normal.y / 2 * (ue[0] -\/ uk[0])));}
\DoxyCodeLine{268                             uu[1] = t\_step / mesh.GetElement(nk)-\/>GetMeasure() * bound-\/>GetMeasure() * (normal.x * (rk[1] + re[1]) / 2 + normal.y * (gk[1] + ge[1]) / 2 + (lambda\_x * normal.x / 2 * (ue[1] -\/ uk[1]) + lambda\_y * normal.y / 2 * (ue[1] -\/ uk[1])));}
\DoxyCodeLine{269                             uu[2] = t\_step / mesh.GetElement(nk)-\/>GetMeasure() * bound-\/>GetMeasure() * (normal.x * (rk[2] + re[2]) / 2 + normal.y * (gk[2] + ge[2]) / 2 + (lambda\_x * normal.x / 2 * (ue[2] -\/ uk[2]) + lambda\_y * normal.y / 2 * (ue[2] -\/ uk[2])));}
\DoxyCodeLine{270                         \}}
\DoxyCodeLine{271 }
\DoxyCodeLine{272                         W[t + 1].S[0][nk] -\/= uu[0];}
\DoxyCodeLine{273                         W[t + 1].S[1][nk] -\/= uu[1];}
\DoxyCodeLine{274                         W[t + 1].S[2][nk] -\/= uu[2];}
\DoxyCodeLine{275                     \}}
\DoxyCodeLine{276                 \}}
\DoxyCodeLine{277                 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < size; ++i)}
\DoxyCodeLine{278                 \{}
\DoxyCodeLine{279 }
\DoxyCodeLine{280                     U[t + 1].S[0][i] = W[t + 1].S[0][i];}
\DoxyCodeLine{281                     U[t + 1].S[1][i] = W[t + 1].S[1][i] / W[t + 1].S[0][i];}
\DoxyCodeLine{282                     U[t + 1].S[2][i] = W[t + 1].S[2][i] / W[t + 1].S[0][i];}
\DoxyCodeLine{283                 \}}
\DoxyCodeLine{284                 W.push\_back(\mbox{\hyperlink{structcorenc_1_1solvers_1_1vector__solution}{vector\_solution}}(size));}
\DoxyCodeLine{285                 U.push\_back(\mbox{\hyperlink{structcorenc_1_1solvers_1_1vector__solution}{vector\_solution}}(size));}
\DoxyCodeLine{286 }
\DoxyCodeLine{287             \}}
\DoxyCodeLine{288             \textcolor{keyword}{const} \textcolor{keyword}{auto} ut = W.size() -\/ 2;}
\DoxyCodeLine{289             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < size; ++i)}
\DoxyCodeLine{290             \{}
\DoxyCodeLine{291                 sol.\mbox{\hyperlink{structcorenc_1_1solvers_1_1vector__solution_a4ec287397ffb7e274ad675a6189460f6}{S}}[0][i] = W[ut].S[0][i];}
\DoxyCodeLine{292                 sol.\mbox{\hyperlink{structcorenc_1_1solvers_1_1vector__solution_a4ec287397ffb7e274ad675a6189460f6}{S}}[1][i] = W[ut].S[1][i];}
\DoxyCodeLine{293                 sol.\mbox{\hyperlink{structcorenc_1_1solvers_1_1vector__solution_a4ec287397ffb7e274ad675a6189460f6}{S}}[2][i] = W[ut].S[2][i];}
\DoxyCodeLine{294             \}}
\DoxyCodeLine{295             \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{296         \}}
\DoxyCodeLine{297 }
\DoxyCodeLine{298         \textcolor{keyword}{template}<\textcolor{keyword}{class} Mesh>}
\DoxyCodeLine{299         \textcolor{keyword}{const} \textcolor{keywordtype}{int} \mbox{\hyperlink{classcorenc_1_1solvers_1_1dg__shallow__water_a68503609a376fd70e0e19a9495748e91}{dg\_shallow\_water<Mesh>::solve}}(}
\DoxyCodeLine{300             \textcolor{keyword}{const} \textcolor{keywordtype}{double} t0,}
\DoxyCodeLine{301             \textcolor{keyword}{const} \textcolor{keywordtype}{double} t1,}
\DoxyCodeLine{302             \textcolor{keyword}{const} Mesh\& mesh,}
\DoxyCodeLine{303             \mbox{\hyperlink{structcorenc_1_1solvers_1_1vector__solution}{vector\_solution}}\& sol,}
\DoxyCodeLine{304             std::vector<double>\& bath,}
\DoxyCodeLine{305             std::vector<double>\& ze,}
\DoxyCodeLine{306             std::vector<double>\& dzx,}
\DoxyCodeLine{307             std::vector<double>\& dzy,}
\DoxyCodeLine{308             std::vector<double>\& dbx,}
\DoxyCodeLine{309             std::vector<double>\& dby,}
\DoxyCodeLine{310             \textcolor{keyword}{const} std::function < \textcolor{keyword}{const} std::vector<double>(\textcolor{keyword}{const} std::vector<double>\&, \textcolor{keyword}{const} \textcolor{keywordtype}{int})>\&R,}
\DoxyCodeLine{311             \textcolor{keyword}{const} std::function < \textcolor{keyword}{const} std::vector<double>(\textcolor{keyword}{const} std::vector<double>\&, \textcolor{keyword}{const} \textcolor{keywordtype}{int})>\&G,}
\DoxyCodeLine{312             \textcolor{keyword}{const} std::function < \textcolor{keyword}{const} std::vector<double>(\textcolor{keyword}{const} std::vector<double>\&, \textcolor{keyword}{const} \textcolor{keywordtype}{int})>\&F,}
\DoxyCodeLine{313             \textcolor{keyword}{const} \textcolor{keywordtype}{bool} WRITE\_FILE)\textcolor{keyword}{ const}}
\DoxyCodeLine{314 \textcolor{keyword}{        }\{}
\DoxyCodeLine{315             std::vector<double> Ut[3];}
\DoxyCodeLine{316             \textcolor{keyword}{const} \textcolor{keywordtype}{int} max\_iter = 30000;}
\DoxyCodeLine{317             \textcolor{keywordtype}{double} dx = 100, dy = 100;}
\DoxyCodeLine{318             \textcolor{comment}{//const double dx = mesh.GetNode(mesh.GetNumberOfNodes() -\/ 1).x -\/ mesh.GetNode(0).x;}}
\DoxyCodeLine{319             \textcolor{comment}{//const double dy = mesh.GetNode(mesh.GetNumberOfNodes() -\/ 1).y -\/ mesh.GetNode(0).y;}}
\DoxyCodeLine{320             \textcolor{comment}{//const double dx = (x1 -\/ x0) / nx;}}
\DoxyCodeLine{321             \textcolor{comment}{//const double dy = (y1 -\/ y0) / ny;}}
\DoxyCodeLine{322             \textcolor{keyword}{const} \textcolor{keywordtype}{int} size = mesh.GetNumberOfElements();}
\DoxyCodeLine{323             \textcolor{keyword}{const} \textcolor{keywordtype}{int} bsize = mesh.GetNumberOfBoundaries();}
\DoxyCodeLine{324 }
\DoxyCodeLine{325             std::vector<vector\_solution> U(2);}
\DoxyCodeLine{326             std::vector<vector\_solution> W(2);}
\DoxyCodeLine{327             U[0].S[0].resize(size);}
\DoxyCodeLine{328             U[0].S[1].resize(size);}
\DoxyCodeLine{329             U[0].S[2].resize(size);}
\DoxyCodeLine{330             U[1].S[0].resize(size);}
\DoxyCodeLine{331             U[1].S[1].resize(size);}
\DoxyCodeLine{332             U[1].S[2].resize(size);}
\DoxyCodeLine{333 }
\DoxyCodeLine{334             W[0].S[0].resize(size);}
\DoxyCodeLine{335             W[0].S[1].resize(size);}
\DoxyCodeLine{336             W[0].S[2].resize(size);}
\DoxyCodeLine{337             W[1].S[0].resize(size);}
\DoxyCodeLine{338             W[1].S[1].resize(size);}
\DoxyCodeLine{339             W[1].S[2].resize(size);}
\DoxyCodeLine{340             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < size; ++i)}
\DoxyCodeLine{341             \{}
\DoxyCodeLine{342                 W[0].S[0][i] = sol.\mbox{\hyperlink{structcorenc_1_1solvers_1_1vector__solution_a4ec287397ffb7e274ad675a6189460f6}{S}}[0][i];}
\DoxyCodeLine{343                 W[0].S[1][i] = sol.\mbox{\hyperlink{structcorenc_1_1solvers_1_1vector__solution_a4ec287397ffb7e274ad675a6189460f6}{S}}[1][i];}
\DoxyCodeLine{344                 W[0].S[2][i] = sol.\mbox{\hyperlink{structcorenc_1_1solvers_1_1vector__solution_a4ec287397ffb7e274ad675a6189460f6}{S}}[2][i];}
\DoxyCodeLine{345 }
\DoxyCodeLine{346                 U[0].S[0][i] = sol.\mbox{\hyperlink{structcorenc_1_1solvers_1_1vector__solution_a4ec287397ffb7e274ad675a6189460f6}{S}}[0][i];}
\DoxyCodeLine{347                 U[0].S[1][i] = sol.\mbox{\hyperlink{structcorenc_1_1solvers_1_1vector__solution_a4ec287397ffb7e274ad675a6189460f6}{S}}[1][i] / sol.\mbox{\hyperlink{structcorenc_1_1solvers_1_1vector__solution_a4ec287397ffb7e274ad675a6189460f6}{S}}[0][i];}
\DoxyCodeLine{348                 U[0].S[2][i] = sol.\mbox{\hyperlink{structcorenc_1_1solvers_1_1vector__solution_a4ec287397ffb7e274ad675a6189460f6}{S}}[2][i] / sol.\mbox{\hyperlink{structcorenc_1_1solvers_1_1vector__solution_a4ec287397ffb7e274ad675a6189460f6}{S}}[0][i];}
\DoxyCodeLine{349             \}}
\DoxyCodeLine{350             \textcolor{keyword}{auto} center = [=](\textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} i)}
\DoxyCodeLine{351             \{}
\DoxyCodeLine{352                 \textcolor{keyword}{const} \textcolor{keyword}{auto}\& elem = mesh.GetElement(i);}
\DoxyCodeLine{353                 std::vector<corenc::Mesh::Point> pts(4);}
\DoxyCodeLine{354                 pts[0] = mesh.GetNode(elem-\/>GetNode(0));}
\DoxyCodeLine{355                 pts[1] = mesh.GetNode(elem-\/>GetNode(1));}
\DoxyCodeLine{356                 pts[2] = mesh.GetNode(elem-\/>GetNode(2));}
\DoxyCodeLine{357                 pts[3] = mesh.GetNode(elem-\/>GetNode(3));}
\DoxyCodeLine{358                 \textcolor{keywordflow}{return} \mbox{\hyperlink{classcorenc_1_1Mesh_1_1Point}{corenc::Mesh::Point}}(pts[0].x + (pts[3].x -\/ pts[0].x) / 2, pts[0].y + (pts[3].y -\/ pts[0].y) / 2);}
\DoxyCodeLine{359             \};}
\DoxyCodeLine{360             \textcolor{keywordtype}{double} t\_step = 0.1;}
\DoxyCodeLine{361             \textcolor{keyword}{const} \textcolor{keywordtype}{double} cfl = 0.1;}
\DoxyCodeLine{362             \textcolor{comment}{// W = [h hu hv]}}
\DoxyCodeLine{363             \textcolor{keywordtype}{double} lambda\_x = 0;}
\DoxyCodeLine{364             \textcolor{keywordtype}{double} lambda\_y = 0;}
\DoxyCodeLine{365             \textcolor{keywordtype}{double} lambdax = 0;}
\DoxyCodeLine{366             \textcolor{keywordtype}{double} lambday = 0;}
\DoxyCodeLine{367             \textcolor{keywordtype}{double} lambda = 0;}
\DoxyCodeLine{368             \textcolor{keywordtype}{double} t\_curr = 0;}
\DoxyCodeLine{369             \textcolor{keywordtype}{double} g = 1;}
\DoxyCodeLine{370             \textcolor{keywordtype}{size\_t} iter\_max = 100;}
\DoxyCodeLine{371             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} t = 0; t < iter\_max \&\& t\_curr < t1; ++t, t\_curr += t\_step)}
\DoxyCodeLine{372             \{}
\DoxyCodeLine{373                 lambda\_x = 0;}
\DoxyCodeLine{374                 lambda\_y = 0;}
\DoxyCodeLine{375                 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < size; ++i)}
\DoxyCodeLine{376                 \{}
\DoxyCodeLine{377                     \textcolor{keyword}{const} \textcolor{keyword}{auto}\& elem = mesh.GetElement(i);}
\DoxyCodeLine{378                     \textcolor{keyword}{const} \textcolor{keyword}{auto}\& res = F(std::vector<double>\{W[t].S[0][i], W[t].S[1][i], W[t].S[2][i]\}, i);}
\DoxyCodeLine{379                     W[t + 1].S[0][i] = W[t].S[0][i] + res[0];}
\DoxyCodeLine{380                     W[t + 1].S[1][i] = W[t].S[1][i] + res[1];}
\DoxyCodeLine{381                     W[t + 1].S[2][i] = W[t].S[2][i] + res[2];}
\DoxyCodeLine{382 }
\DoxyCodeLine{383                     lambda\_x = std::max(fabs(U[t].S[1][i]) + sqrt(g*U[t].S[0][i]), lambda\_x);}
\DoxyCodeLine{384                     lambda\_y = std::max(fabs(U[t].S[2][i]) + sqrt(g*U[t].S[0][i]), lambda\_y);}
\DoxyCodeLine{385                     dx = std::min(mesh.GetNode(elem-\/>GetNode(3)).x -\/ mesh.GetNode(elem-\/>GetNode(0)).x, dx);}
\DoxyCodeLine{386                     dy = std::min(mesh.GetNode(elem-\/>GetNode(3)).y -\/ mesh.GetNode(elem-\/>GetNode(0)).y, dy);}
\DoxyCodeLine{387                     \textcolor{comment}{//lambda\_x = std::min(U[t].S[1][i])}}
\DoxyCodeLine{388                     \textcolor{comment}{//lambda\_x = std::max(fabs(U[t].S[1][i]), lambda\_x);}}
\DoxyCodeLine{389                     \textcolor{comment}{//lambda\_y = std::max(fabs(U[t].S[2][i]), lambda\_y);}}
\DoxyCodeLine{390                 \}}
\DoxyCodeLine{391                 t\_step = cfl / 2 * std::min(dx / lambda\_x, dy / lambda\_y);}
\DoxyCodeLine{392                 \textcolor{comment}{//std::cout << t\_step << std::endl;}}
\DoxyCodeLine{393                 \textcolor{keywordflow}{if} (t\_curr + t\_step > t1)}
\DoxyCodeLine{394                     t\_step = t1 -\/ t\_curr;}
\DoxyCodeLine{395                 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < bsize; ++i)}
\DoxyCodeLine{396                 \{}
\DoxyCodeLine{397                     \textcolor{keyword}{const} \textcolor{keyword}{auto}\& bound = mesh.GetBoundary(i);}
\DoxyCodeLine{398                     \textcolor{keyword}{const} \textcolor{keywordtype}{int} nk = bound-\/>GetNeighbour(0);}
\DoxyCodeLine{399                     \textcolor{keyword}{const} \textcolor{keywordtype}{int} ne = bound-\/>GetNeighbour(1);}
\DoxyCodeLine{400                     \textcolor{keyword}{const} \textcolor{keyword}{auto}\& normal = bound-\/>GetNormal();}
\DoxyCodeLine{401                     \textcolor{keywordflow}{if} (ne > -\/1)}
\DoxyCodeLine{402                     \{}
\DoxyCodeLine{403                         \textcolor{keyword}{const} \textcolor{keyword}{auto}\& normal = bound-\/>GetNormal();}
\DoxyCodeLine{404                         std::vector<double> wk(3);}
\DoxyCodeLine{405                         wk[0] = U[t].S[0][nk];}
\DoxyCodeLine{406                         wk[1] = U[t].S[1][nk] * U[t].S[0][nk];}
\DoxyCodeLine{407                         wk[2] = U[t].S[2][nk] * U[t].S[0][nk];}
\DoxyCodeLine{408 }
\DoxyCodeLine{409                         std::vector<double> we(3);}
\DoxyCodeLine{410                         we[0] = U[t].S[0][ne];}
\DoxyCodeLine{411                         we[1] = U[t].S[1][ne] * U[t].S[0][ne];}
\DoxyCodeLine{412                         we[2] = U[t].S[2][ne] * U[t].S[0][ne];}
\DoxyCodeLine{413 }
\DoxyCodeLine{414                         lambda\_x = std::max(fabs(U[t].S[1][nk]) + sqrt(g * U[t].S[0][nk]), fabs(U[t].S[1][ne]) + sqrt(g * U[t].S[0][ne]));}
\DoxyCodeLine{415                         lambda\_y = std::max(fabs(U[t].S[2][nk]) + sqrt(g * U[t].S[0][nk]), fabs(U[t].S[2][ne]) + sqrt(g * U[t].S[0][ne]));}
\DoxyCodeLine{416 }
\DoxyCodeLine{417                         \textcolor{comment}{//lambda\_x = std::max(fabs(U[t].S[1][nk]), fabs(U[t].S[1][ne]));}}
\DoxyCodeLine{418                         \textcolor{comment}{//lambda\_y = std::max(fabs(U[t].S[2][nk]), fabs(U[t].S[2][ne]));}}
\DoxyCodeLine{419 }
\DoxyCodeLine{420 }
\DoxyCodeLine{421                         lambdax = std::max(lambdax, lambda\_x);}
\DoxyCodeLine{422                         lambday = std::max(lambday, lambda\_y);}
\DoxyCodeLine{423                         \textcolor{keywordtype}{double} ll = std::max(lambda\_x, lambda\_y);}
\DoxyCodeLine{424                         \textcolor{comment}{//cout << "{}max:\(\backslash\)t"{} << ll << endl;}}
\DoxyCodeLine{425                         std::vector<double> uk(3);}
\DoxyCodeLine{426                         uk[0] = U[t].S[0][nk];}
\DoxyCodeLine{427                         uk[1] = U[t].S[1][nk];}
\DoxyCodeLine{428                         uk[2] = U[t].S[2][nk];}
\DoxyCodeLine{429 }
\DoxyCodeLine{430                         std::vector<double> ue(3);}
\DoxyCodeLine{431                         ue[0] = U[t].S[0][ne];}
\DoxyCodeLine{432                         ue[1] = U[t].S[1][ne];}
\DoxyCodeLine{433                         ue[2] = U[t].S[2][ne];}
\DoxyCodeLine{434 }
\DoxyCodeLine{435                         \textcolor{keyword}{const} \textcolor{keyword}{auto} rk = R(uk, nk);}
\DoxyCodeLine{436                         \textcolor{keyword}{const} \textcolor{keyword}{auto} re = R(ue, ne);}
\DoxyCodeLine{437                         \textcolor{keyword}{const} \textcolor{keyword}{auto} gk = G(uk, nk);}
\DoxyCodeLine{438                         \textcolor{keyword}{const} \textcolor{keyword}{auto} ge = G(ue, ne);}
\DoxyCodeLine{439 }
\DoxyCodeLine{440                         std::vector<double> uu(3);}
\DoxyCodeLine{441                         uu[0] = t\_step / mesh.GetElement(nk)-\/>GetMeasure() * bound-\/>GetMeasure() * (normal.x * (rk[0] + re[0]) / 2 + normal.y * (gk[0] + ge[0]) / 2 -\/ (lambda\_x * normal.x / 2 * (ue[0] -\/ uk[0]) + lambda\_y * normal.y / 2 * (ue[0] -\/ uk[0])));}
\DoxyCodeLine{442                         uu[1] = t\_step / mesh.GetElement(nk)-\/>GetMeasure() * bound-\/>GetMeasure() * (normal.x * (rk[1] + re[1]) / 2 + normal.y * (gk[1] + ge[1]) / 2 -\/ (lambda\_x * normal.x / 2 * (ue[1] -\/ uk[1]) + lambda\_y * normal.y / 2 * (ue[1] -\/ uk[1])));}
\DoxyCodeLine{443                         uu[2] = t\_step / mesh.GetElement(nk)-\/>GetMeasure() * bound-\/>GetMeasure() * (normal.x * (rk[2] + re[2]) / 2 + normal.y * (gk[2] + ge[2]) / 2 -\/ (lambda\_x * normal.x / 2 * (ue[2] -\/ uk[2]) + lambda\_y * normal.y / 2 * (ue[2] -\/ uk[2])));}
\DoxyCodeLine{444                         W[t + 1].S[0][nk] -\/= uu[0];}
\DoxyCodeLine{445                         W[t + 1].S[1][nk] -\/= uu[1];}
\DoxyCodeLine{446                         W[t + 1].S[2][nk] -\/= uu[2];}
\DoxyCodeLine{447 }
\DoxyCodeLine{448                         uu[0] = t\_step / mesh.GetElement(nk)-\/>GetMeasure() * bound-\/>GetMeasure() * (-\/normal.x * (rk[0] + re[0]) / 2 -\/ normal.y * (gk[0] + ge[0]) / 2 + (lambda\_x * normal.x / 2 * (ue[0] -\/ uk[0]) + lambda\_y * normal.y / 2 * (ue[0] -\/ uk[0])));}
\DoxyCodeLine{449                         uu[1] = t\_step / mesh.GetElement(nk)-\/>GetMeasure() * bound-\/>GetMeasure() * (-\/normal.x * (rk[1] + re[1]) / 2 -\/ normal.y * (gk[1] + ge[1]) / 2 + (lambda\_x * normal.x / 2 * (ue[1] -\/ uk[1]) + lambda\_y * normal.y / 2 * (ue[1] -\/ uk[1])));}
\DoxyCodeLine{450                         uu[2] = t\_step / mesh.GetElement(nk)-\/>GetMeasure() * bound-\/>GetMeasure() * (-\/normal.x * (rk[2] + re[2]) / 2 -\/ normal.y * (gk[2] + ge[2]) / 2 + (lambda\_x * normal.x / 2 * (ue[2] -\/ uk[2]) + lambda\_y * normal.y / 2 * (ue[2] -\/ uk[2])));}
\DoxyCodeLine{451                         W[t + 1].S[0][ne] -\/= uu[0];}
\DoxyCodeLine{452                         W[t + 1].S[1][ne] -\/= uu[1];}
\DoxyCodeLine{453                         W[t + 1].S[2][ne] -\/= uu[2];}
\DoxyCodeLine{454 }
\DoxyCodeLine{455 }
\DoxyCodeLine{456                     \}}
\DoxyCodeLine{457                 \}}
\DoxyCodeLine{458                 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < bsize; ++i)}
\DoxyCodeLine{459                 \{}
\DoxyCodeLine{460                     \textcolor{keyword}{const} \textcolor{keyword}{auto}\& bound = mesh.GetBoundary(i);}
\DoxyCodeLine{461                     \textcolor{keyword}{const} \textcolor{keywordtype}{int} nk = bound-\/>GetNeighbour(0);}
\DoxyCodeLine{462                     \textcolor{keyword}{const} \textcolor{keywordtype}{int} ne = bound-\/>GetNeighbour(1);}
\DoxyCodeLine{463                     \textcolor{keywordflow}{if} (ne == -\/1)}
\DoxyCodeLine{464                     \{}
\DoxyCodeLine{465                         \textcolor{keyword}{auto} normal = bound-\/>GetNormal();}
\DoxyCodeLine{466 }
\DoxyCodeLine{467                         std::vector<double> u(3);}
\DoxyCodeLine{468                         u[0] = U[t].S[0][nk];}
\DoxyCodeLine{469                         u[1] = -\/U[t].S[1][nk];}
\DoxyCodeLine{470                         u[2] = -\/U[t].S[2][nk];}
\DoxyCodeLine{471 }
\DoxyCodeLine{472                         \textcolor{comment}{//u[0] = U[t].S[0][nk];}}
\DoxyCodeLine{473                         \textcolor{comment}{//u[1] = U[t].S[1][nk];}}
\DoxyCodeLine{474                         \textcolor{comment}{//u[2] = U[t].S[2][nk];}}
\DoxyCodeLine{475 }
\DoxyCodeLine{476                         lambdax = std::max(lambdax, lambda\_x);}
\DoxyCodeLine{477                         lambday = std::max(lambday, lambda\_y);}
\DoxyCodeLine{478 }
\DoxyCodeLine{479                         std::vector<double> uk(3);}
\DoxyCodeLine{480                         uk[0] = U[t].S[0][nk];}
\DoxyCodeLine{481                         uk[1] = U[t].S[1][nk];}
\DoxyCodeLine{482                         uk[2] = U[t].S[2][nk];}
\DoxyCodeLine{483 }
\DoxyCodeLine{484                         std::vector<double> ue(3);}
\DoxyCodeLine{485                         ue[0] = u[0];}
\DoxyCodeLine{486                         ue[1] = u[1];}
\DoxyCodeLine{487                         ue[2] = u[2];}
\DoxyCodeLine{488 }
\DoxyCodeLine{489                         \textcolor{keyword}{const} \textcolor{keyword}{auto} rk = R(uk, nk);}
\DoxyCodeLine{490                         \textcolor{keyword}{const} \textcolor{keyword}{auto} re = R(ue, nk);}
\DoxyCodeLine{491                         \textcolor{keyword}{const} \textcolor{keyword}{auto} gk = G(uk, nk);}
\DoxyCodeLine{492                         \textcolor{keyword}{const} \textcolor{keyword}{auto} ge = G(ue, nk);}
\DoxyCodeLine{493                         lambda\_x = std::max(fabs(uk[1]) + sqrt(g*uk[0]), fabs(ue[1]) + sqrt(g*ue[0]));}
\DoxyCodeLine{494                         lambda\_y = std::max(fabs(uk[2]) + sqrt(g*uk[0]), fabs(ue[2]) + sqrt(g*ue[0]));}
\DoxyCodeLine{495                         std::vector<double> uu(3);}
\DoxyCodeLine{496                         \textcolor{keywordflow}{if} (normal.x > 0 || normal.y > 0)}
\DoxyCodeLine{497                         \{}
\DoxyCodeLine{498                             uu[0] = t\_step / mesh.GetElement(nk)-\/>GetMeasure() * bound-\/>GetMeasure() * (normal.x * (rk[0] + re[0]) / 2 + normal.y * (gk[0] + ge[0]) / 2 -\/ (lambda\_x * normal.x / 2 * (ue[0] -\/ uk[0]) + lambda\_y * normal.y / 2 * (ue[0] -\/ uk[0])));}
\DoxyCodeLine{499                             uu[1] = t\_step / mesh.GetElement(nk)-\/>GetMeasure() * bound-\/>GetMeasure() * (normal.x * (rk[1] + re[1]) / 2 + normal.y * (gk[1] + ge[1]) / 2 -\/ (lambda\_x * normal.x / 2 * (ue[1] -\/ uk[1]) + lambda\_y * normal.y / 2 * (ue[1] -\/ uk[1])));}
\DoxyCodeLine{500                             uu[2] = t\_step / mesh.GetElement(nk)-\/>GetMeasure() * bound-\/>GetMeasure() * (normal.x * (rk[2] + re[2]) / 2 + normal.y * (gk[2] + ge[2]) / 2 -\/ (lambda\_x * normal.x / 2 * (ue[2] -\/ uk[2]) + lambda\_y * normal.y / 2 * (ue[2] -\/ uk[2])));}
\DoxyCodeLine{501                         \}}
\DoxyCodeLine{502                         \textcolor{keywordflow}{else}}
\DoxyCodeLine{503                         \{}
\DoxyCodeLine{504                             uu[0] = t\_step / mesh.GetElement(nk)-\/>GetMeasure() * bound-\/>GetMeasure() * (normal.x * (rk[0] + re[0]) / 2 + normal.y * (gk[0] + ge[0]) / 2 + (lambda\_x * normal.x / 2 * (ue[0] -\/ uk[0]) + lambda\_y * normal.y / 2 * (ue[0] -\/ uk[0])));}
\DoxyCodeLine{505                             uu[1] = t\_step / mesh.GetElement(nk)-\/>GetMeasure() * bound-\/>GetMeasure() * (normal.x * (rk[1] + re[1]) / 2 + normal.y * (gk[1] + ge[1]) / 2 + (lambda\_x * normal.x / 2 * (ue[1] -\/ uk[1]) + lambda\_y * normal.y / 2 * (ue[1] -\/ uk[1])));}
\DoxyCodeLine{506                             uu[2] = t\_step / mesh.GetElement(nk)-\/>GetMeasure() * bound-\/>GetMeasure() * (normal.x * (rk[2] + re[2]) / 2 + normal.y * (gk[2] + ge[2]) / 2 + (lambda\_x * normal.x / 2 * (ue[2] -\/ uk[2]) + lambda\_y * normal.y / 2 * (ue[2] -\/ uk[2])));}
\DoxyCodeLine{507                         \}}
\DoxyCodeLine{508 }
\DoxyCodeLine{509                         W[t + 1].S[0][nk] -\/= uu[0];}
\DoxyCodeLine{510                         W[t + 1].S[1][nk] -\/= uu[1];}
\DoxyCodeLine{511                         W[t + 1].S[2][nk] -\/= uu[2];}
\DoxyCodeLine{512                     \}}
\DoxyCodeLine{513                 \}}
\DoxyCodeLine{514                 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < size; ++i)}
\DoxyCodeLine{515                 \{}
\DoxyCodeLine{516 }
\DoxyCodeLine{517                     U[t + 1].S[0][i] = W[t + 1].S[0][i];}
\DoxyCodeLine{518                     U[t + 1].S[1][i] = W[t + 1].S[1][i] / W[t + 1].S[0][i];}
\DoxyCodeLine{519                     U[t + 1].S[2][i] = W[t + 1].S[2][i] / W[t + 1].S[0][i];}
\DoxyCodeLine{520                 \}}
\DoxyCodeLine{521                 W.push\_back(\mbox{\hyperlink{structcorenc_1_1solvers_1_1vector__solution}{vector\_solution}}(size));}
\DoxyCodeLine{522                 U.push\_back(\mbox{\hyperlink{structcorenc_1_1solvers_1_1vector__solution}{vector\_solution}}(size));}
\DoxyCodeLine{523 }
\DoxyCodeLine{524                 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} k = 0; k < bsize; ++k)}
\DoxyCodeLine{525                 \{}
\DoxyCodeLine{526                     \textcolor{keyword}{const} \textcolor{keyword}{auto}\& bound = mesh.GetBoundary(k);}
\DoxyCodeLine{527                     \textcolor{keyword}{const} \textcolor{keyword}{auto} nk = bound-\/>GetNeighbour(0);}
\DoxyCodeLine{528                     \textcolor{keyword}{const} \textcolor{keyword}{auto} ne = bound-\/>GetNeighbour(1);}
\DoxyCodeLine{529                     ze[nk] = W[t + 1].S[0][nk] -\/ bath[nk];}
\DoxyCodeLine{530                     \textcolor{keywordflow}{if} (ne > -\/1)}
\DoxyCodeLine{531                     \{}
\DoxyCodeLine{532                         ze[ne] = W[t + 1].S[0][ne] -\/ bath[ne];}
\DoxyCodeLine{533                         \textcolor{keyword}{const} \textcolor{keyword}{auto} ce = center(ne);}
\DoxyCodeLine{534                         \textcolor{keyword}{const} \textcolor{keyword}{auto} ck = center(nk);}
\DoxyCodeLine{535                         \textcolor{keyword}{const} \textcolor{keywordtype}{double} cx = ce.x -\/ ck.x;}
\DoxyCodeLine{536                         \textcolor{keyword}{const} \textcolor{keywordtype}{double} cy = ce.y -\/ ck.y;}
\DoxyCodeLine{537                         \textcolor{keywordflow}{if} (fabs(cy) < 1e-\/13)}
\DoxyCodeLine{538                         \{}
\DoxyCodeLine{539                             dzx[nk] = (ze[ne] -\/ ze[nk]) / cx;}
\DoxyCodeLine{540                             dzx[ne] = dzx[nk];}
\DoxyCodeLine{541                             dbx[nk] = (bath[ne] -\/ bath[nk]) / cx;}
\DoxyCodeLine{542                             dbx[ne] = dbx[nk];}
\DoxyCodeLine{543                         \}}
\DoxyCodeLine{544                         \textcolor{keywordflow}{else}}
\DoxyCodeLine{545                         \{}
\DoxyCodeLine{546                             dzy[nk] = (ze[ne] -\/ ze[nk]) / cy;}
\DoxyCodeLine{547                             dzy[ne] = dzy[nk];}
\DoxyCodeLine{548                             dby[nk] = (bath[ne] -\/ bath[nk]) / cy;}
\DoxyCodeLine{549                             dby[ne] = dby[nk];}
\DoxyCodeLine{550                         \}}
\DoxyCodeLine{551                     \}}
\DoxyCodeLine{552                 \}}
\DoxyCodeLine{553             \}}
\DoxyCodeLine{554             \textcolor{comment}{/*const auto ut = W.size() -\/ 2;}}
\DoxyCodeLine{555 \textcolor{comment}{            for (size\_t i = 0; i < size; ++i)}}
\DoxyCodeLine{556 \textcolor{comment}{            \{}}
\DoxyCodeLine{557 \textcolor{comment}{                sol.S[0][i] = W[ut].S[0][i];}}
\DoxyCodeLine{558 \textcolor{comment}{                sol.S[1][i] = W[ut].S[1][i];}}
\DoxyCodeLine{559 \textcolor{comment}{                sol.S[2][i] = W[ut].S[2][i];}}
\DoxyCodeLine{560 \textcolor{comment}{            \}}}
\DoxyCodeLine{561 \textcolor{comment}{            std::ofstream ofs;}}
\DoxyCodeLine{562 \textcolor{comment}{            ofs.open("{}meshU.txt"{});}}
\DoxyCodeLine{563 \textcolor{comment}{            const size\_t t\_r = U.size() -\/ 1;}}
\DoxyCodeLine{564 \textcolor{comment}{            ofs << t\_r << std::endl;}}
\DoxyCodeLine{565 \textcolor{comment}{            for (size\_t i = 0; i < t\_r; ++i)}}
\DoxyCodeLine{566 \textcolor{comment}{                for (size\_t j = 0; j < size; ++j)}}
\DoxyCodeLine{567 \textcolor{comment}{                    ofs << U[i].S[0][j] -\/ bath[j] << std::endl;}}
\DoxyCodeLine{568 \textcolor{comment}{            ofs.close();*/}}
\DoxyCodeLine{569             \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{570         \}}
\DoxyCodeLine{571     \}}
\DoxyCodeLine{572 \}}
\DoxyCodeLine{573 }
\DoxyCodeLine{574 }
\DoxyCodeLine{575 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// !CORENC\_SOLVERS\_DG\_SOLVER\_SHALLOW\_WATER\_H\_}}

\end{DoxyCode}
